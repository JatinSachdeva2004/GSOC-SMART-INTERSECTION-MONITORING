from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QLabel, QSizePolicy
)
from PySide6.QtCore import Qt, Signal, QSize
from PySide6.QtGui import QPixmap, QImage

import cv2
import numpy as np

class SimpleLiveDisplay(QWidget):
    """Simpler implementation for video display using QLabel instead of QGraphicsView"""
    
    video_dropped = Signal(str)  # For drag and drop compatibility
    
    def __init__(self):
        super().__init__()
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        
        # Create QLabel for display
        self.display_label = QLabel()
        self.display_label.setAlignment(Qt.AlignCenter)
        self.display_label.setMinimumSize(640, 480)
        self.display_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.display_label.setStyleSheet("background-color: black;")
        
        # Set up drag and drop
        self.setAcceptDrops(True)
        
        # Add to layout
        self.layout.addWidget(self.display_label)
        
        # Initialize with black screen
        self.reset_display()
        
    def update_frame(self, pixmap):
        """Update the display with a new frame"""
        if pixmap and not pixmap.isNull():
            print(f"DEBUG: SimpleLiveDisplay updating with pixmap {pixmap.width()}x{pixmap.height()}")
            
            try:
                # Get current label size
                label_size = self.display_label.size()
                if label_size.width() <= 1 or label_size.height() <= 1:
                    # If label doesn't have valid size yet, use a reasonable default
                    label_size = QSize(640, 480)
                
                # Make a deep copy to prevent any sharing issues
                pixmap_copy = QPixmap(pixmap)
                
                # Scale the pixmap to fit the label while maintaining aspect ratio
                scaled_pixmap = pixmap_copy.scaled(
                    label_size,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                )
                
                # Set the pixmap to the label
                self.display_label.setPixmap(scaled_pixmap)
                
                # Force an immediate update
                self.display_label.update()
                print("DEBUG: SimpleLiveDisplay - pixmap set successfully")
            
            except Exception as e:
                print(f"ERROR in SimpleLiveDisplay.update_frame: {e}")
                import traceback
                traceback.print_exc()
                
        else:
            print("DEBUG: SimpleLiveDisplay received null or invalid pixmap")
            
    def resizeEvent(self, event):
        """Handle resize events"""
        super().resizeEvent(event)
        # If we have a pixmap, rescale it to fit the new size
        if not self.display_label.pixmap() or self.display_label.pixmap().isNull():
            return
            
        try:
            scaled_pixmap = self.display_label.pixmap().scaled(
                self.display_label.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            self.display_label.setPixmap(scaled_pixmap)
        except Exception as e:
            print(f"ERROR in SimpleLiveDisplay.resizeEvent: {e}")
        
    def reset_display(self):
        """Reset display to black"""
        try:
            blank = QPixmap(640, 480)
            blank.fill(Qt.black)
            self.display_label.setPixmap(blank)
        except Exception as e:
            print(f"ERROR in SimpleLiveDisplay.reset_display: {e}")
        
    def dragEnterEvent(self, event):
        """Handle drag enter events"""
        if event.mimeData().hasUrls():
            url = event.mimeData().urls()[0].toLocalFile()
            if url.lower().endswith(('.mp4', '.avi', '.mov', '.mkv', '.webm')):
                event.acceptProposedAction()
                
    def dropEvent(self, event):
        """Handle drop events"""
        if event.mimeData().hasUrls():
            url = event.mimeData().urls()[0].toLocalFile()
            if url.lower().endswith(('.mp4', '.avi', '.mov', '.mkv', '.webm')):
                self.video_dropped.emit(url)
